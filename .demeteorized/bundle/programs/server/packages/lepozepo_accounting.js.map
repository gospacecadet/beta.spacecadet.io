{"version":3,"sources":["meteor://ðŸ’»app/packages/lepozepo_accounting/packages/lepozepo_accounting.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qH","file":"/packages/lepozepo_accounting.js","sourcesContent":["(function () {\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                      //\n// packages/lepozepo:accounting/accounting.js                                                           //\n//                                                                                                      //\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                        //\n/*!                                                                                                     // 1\n * accounting.js v0.3.2                                                                                 // 2\n * Copyright 2011, Joss Crowcroft                                                                       // 3\n *                                                                                                      // 4\n * Freely distributable under the MIT license.                                                          // 5\n * Portions of accounting.js are inspired or borrowed from underscore.js                                // 6\n *                                                                                                      // 7\n * Full details and documentation:                                                                      // 8\n * http://josscrowcroft.github.com/accounting.js/                                                       // 9\n */                                                                                                     // 10\n                                                                                                        // 11\n(function(root, undefined) {                                                                            // 12\n                                                                                                        // 13\n\t/* --- Setup --- */                                                                                    // 14\n                                                                                                        // 15\n\t// Create the local library object, to be exported or referenced globally later                        // 16\n\tvar lib = {};                                                                                          // 17\n                                                                                                        // 18\n\t// Current version                                                                                     // 19\n\tlib.version = '0.3.2';                                                                                 // 20\n                                                                                                        // 21\n                                                                                                        // 22\n\t/* --- Exposed settings --- */                                                                         // 23\n                                                                                                        // 24\n\t// The library's settings configuration object. Contains default parameters for                        // 25\n\t// currency and number formatting                                                                      // 26\n\tlib.settings = {                                                                                       // 27\n\t\tcurrency: {                                                                                           // 28\n\t\t\tsymbol : \"$\",\t\t// default currency symbol is '$'                                                     // 29\n\t\t\tformat : \"%s%v\",\t// controls output: %s = symbol, %v = value (can be object, see docs)               // 30\n\t\t\tdecimal : \".\",\t\t// decimal point separator                                                           // 31\n\t\t\tthousand : \",\",\t\t// thousands separator                                                              // 32\n\t\t\tprecision : 2,\t\t// decimal places                                                                    // 33\n\t\t\tgrouping : 3\t\t// digit grouping (not implemented yet)                                                // 34\n\t\t},                                                                                                    // 35\n\t\tnumber: {                                                                                             // 36\n\t\t\tprecision : 0,\t\t// default precision on numbers is 0                                                 // 37\n\t\t\tgrouping : 3,\t\t// digit grouping (not implemented yet)                                               // 38\n\t\t\tthousand : \",\",                                                                                      // 39\n\t\t\tdecimal : \".\"                                                                                        // 40\n\t\t}                                                                                                     // 41\n\t};                                                                                                     // 42\n                                                                                                        // 43\n                                                                                                        // 44\n\t/* --- Internal Helper Methods --- */                                                                  // 45\n                                                                                                        // 46\n\t// Store reference to possibly-available ECMAScript 5 methods for later                                // 47\n\tvar nativeMap = Array.prototype.map,                                                                   // 48\n\t\tnativeIsArray = Array.isArray,                                                                        // 49\n\t\ttoString = Object.prototype.toString;                                                                 // 50\n                                                                                                        // 51\n\t/**                                                                                                    // 52\n\t * Tests whether supplied parameter is a string                                                        // 53\n\t * from underscore.js                                                                                  // 54\n\t */                                                                                                    // 55\n\tfunction isString(obj) {                                                                               // 56\n\t\treturn !!(obj === '' || (obj && obj.charCodeAt && obj.substr));                                       // 57\n\t}                                                                                                      // 58\n                                                                                                        // 59\n\t/**                                                                                                    // 60\n\t * Tests whether supplied parameter is a string                                                        // 61\n\t * from underscore.js, delegates to ECMA5's native Array.isArray                                       // 62\n\t */                                                                                                    // 63\n\tfunction isArray(obj) {                                                                                // 64\n\t\treturn nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]';                  // 65\n\t}                                                                                                      // 66\n                                                                                                        // 67\n\t/**                                                                                                    // 68\n\t * Tests whether supplied parameter is a true object                                                   // 69\n\t */                                                                                                    // 70\n\tfunction isObject(obj) {                                                                               // 71\n\t\treturn toString.call(obj) === '[object Object]';                                                      // 72\n\t}                                                                                                      // 73\n                                                                                                        // 74\n\t/**                                                                                                    // 75\n\t * Extends an object with a defaults object, similar to underscore's _.defaults                        // 76\n\t *                                                                                                     // 77\n\t * Used for abstracting parameter handling from API methods                                            // 78\n\t */                                                                                                    // 79\n\tfunction defaults(object, defs) {                                                                      // 80\n\t\tvar key;                                                                                              // 81\n\t\tobject = object || {};                                                                                // 82\n\t\tdefs = defs || {};                                                                                    // 83\n\t\t// Iterate over object non-prototype properties:                                                      // 84\n\t\tfor (key in defs) {                                                                                   // 85\n\t\t\tif (defs.hasOwnProperty(key)) {                                                                      // 86\n\t\t\t\t// Replace values with defaults only if undefined (allow empty/zero values):                        // 87\n\t\t\t\tif (object[key] == null) object[key] = defs[key];                                                   // 88\n\t\t\t}                                                                                                    // 89\n\t\t}                                                                                                     // 90\n\t\treturn object;                                                                                        // 91\n\t}                                                                                                      // 92\n                                                                                                        // 93\n\t/**                                                                                                    // 94\n\t * Implementation of `Array.map()` for iteration loops                                                 // 95\n\t *                                                                                                     // 96\n\t * Returns a new Array as a result of calling `iterator` on each array value.                          // 97\n\t * Defers to native Array.map if available                                                             // 98\n\t */                                                                                                    // 99\n\tfunction map(obj, iterator, context) {                                                                 // 100\n\t\tvar results = [], i, j;                                                                               // 101\n                                                                                                        // 102\n\t\tif (!obj) return results;                                                                             // 103\n                                                                                                        // 104\n\t\t// Use native .map method if it exists:                                                               // 105\n\t\tif (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);                            // 106\n                                                                                                        // 107\n\t\t// Fallback for native .map:                                                                          // 108\n\t\tfor (i = 0, j = obj.length; i < j; i++ ) {                                                            // 109\n\t\t\tresults[i] = iterator.call(context, obj[i], i, obj);                                                 // 110\n\t\t}                                                                                                     // 111\n\t\treturn results;                                                                                       // 112\n\t}                                                                                                      // 113\n                                                                                                        // 114\n\t/**                                                                                                    // 115\n\t * Check and normalise the value of precision (must be positive integer)                               // 116\n\t */                                                                                                    // 117\n\tfunction checkPrecision(val, base) {                                                                   // 118\n\t\tval = Math.round(Math.abs(val));                                                                      // 119\n\t\treturn isNaN(val)? base : val;                                                                        // 120\n\t}                                                                                                      // 121\n                                                                                                        // 122\n                                                                                                        // 123\n\t/**                                                                                                    // 124\n\t * Parses a format string or object and returns format obj for use in rendering                        // 125\n\t *                                                                                                     // 126\n\t * `format` is either a string with the default (positive) format, or object                           // 127\n\t * containing `pos` (required), `neg` and `zero` values (or a function returning                       // 128\n\t * either a string or object)                                                                          // 129\n\t *                                                                                                     // 130\n\t * Either string or format.pos must contain \"%v\" (value) to be valid                                   // 131\n\t */                                                                                                    // 132\n\tfunction checkCurrencyFormat(format) {                                                                 // 133\n\t\tvar defaults = lib.settings.currency.format;                                                          // 134\n                                                                                                        // 135\n\t\t// Allow function as format parameter (should return string or object):                               // 136\n\t\tif ( typeof format === \"function\" ) format = format();                                                // 137\n                                                                                                        // 138\n\t\t// Format can be a string, in which case `value` (\"%v\") must be present:                              // 139\n\t\tif ( isString( format ) && format.match(\"%v\") ) {                                                     // 140\n                                                                                                        // 141\n\t\t\t// Create and return positive, negative and zero formats:                                            // 142\n\t\t\treturn {                                                                                             // 143\n\t\t\t\tpos : format,                                                                                       // 144\n\t\t\t\tneg : format.replace(\"-\", \"\").replace(\"%v\", \"-%v\"),                                                 // 145\n\t\t\t\tzero : format                                                                                       // 146\n\t\t\t};                                                                                                   // 147\n                                                                                                        // 148\n\t\t// If no format, or object is missing valid positive value, use defaults:                             // 149\n\t\t} else if ( !format || !format.pos || !format.pos.match(\"%v\") ) {                                     // 150\n                                                                                                        // 151\n\t\t\t// If defaults is a string, casts it to an object for faster checking next time:                     // 152\n\t\t\treturn ( !isString( defaults ) ) ? defaults : lib.settings.currency.format = {                       // 153\n\t\t\t\tpos : defaults,                                                                                     // 154\n\t\t\t\tneg : defaults.replace(\"%v\", \"-%v\"),                                                                // 155\n\t\t\t\tzero : defaults                                                                                     // 156\n\t\t\t};                                                                                                   // 157\n                                                                                                        // 158\n\t\t}                                                                                                     // 159\n\t\t// Otherwise, assume format was fine:                                                                 // 160\n\t\treturn format;                                                                                        // 161\n\t}                                                                                                      // 162\n                                                                                                        // 163\n                                                                                                        // 164\n\t/* --- API Methods --- */                                                                              // 165\n                                                                                                        // 166\n\t/**                                                                                                    // 167\n\t * Takes a string/array of strings, removes all formatting/cruft and returns the raw float value       // 168\n\t * alias: accounting.`parse(string)`                                                                   // 169\n\t *                                                                                                     // 170\n\t * Decimal must be included in the regular expression to match floats (default: \".\"), so if the number // 171\n\t * uses a non-standard decimal separator, provide it as the second argument.                           // 172\n\t *                                                                                                     // 173\n\t * Also matches bracketed negatives (eg. \"$ (1.99)\" => -1.99)                                          // 174\n\t *                                                                                                     // 175\n\t * Doesn't throw any errors (`NaN`s become 0) but this may change in future                            // 176\n\t */                                                                                                    // 177\n\tvar unformat = lib.unformat = lib.parse = function(value, decimal) {                                   // 178\n\t\t// Recursively unformat arrays:                                                                       // 179\n\t\tif (isArray(value)) {                                                                                 // 180\n\t\t\treturn map(value, function(val) {                                                                    // 181\n\t\t\t\treturn unformat(val, decimal);                                                                      // 182\n\t\t\t});                                                                                                  // 183\n\t\t}                                                                                                     // 184\n                                                                                                        // 185\n\t\t// Fails silently (need decent errors):                                                               // 186\n\t\tvalue = value || 0;                                                                                   // 187\n                                                                                                        // 188\n\t\t// Return the value as-is if it's already a number:                                                   // 189\n\t\tif (typeof value === \"number\") return value;                                                          // 190\n                                                                                                        // 191\n\t\t// Default decimal point is \".\" but could be set to eg. \",\" in opts:                                  // 192\n\t\tdecimal = decimal || \".\";                                                                             // 193\n                                                                                                        // 194\n\t\t // Build regex to strip out everything except digits, decimal point and minus sign:                  // 195\n\t\tvar regex = new RegExp(\"[^0-9-\" + decimal + \"]\", [\"g\"]),                                              // 196\n\t\t\tunformatted = parseFloat(                                                                            // 197\n\t\t\t\t(\"\" + value)                                                                                        // 198\n\t\t\t\t.replace(/\\((.*)\\)/, \"-$1\") // replace bracketed values with negatives                              // 199\n\t\t\t\t.replace(regex, '')         // strip out any cruft                                                  // 200\n\t\t\t\t.replace(decimal, '.')      // make sure decimal point is standard                                  // 201\n\t\t\t);                                                                                                   // 202\n                                                                                                        // 203\n\t\t// This will fail silently which may cause trouble, let's wait and see:                               // 204\n\t\treturn !isNaN(unformatted) ? unformatted : 0;                                                         // 205\n\t};                                                                                                     // 206\n                                                                                                        // 207\n                                                                                                        // 208\n\t/**                                                                                                    // 209\n\t * Implementation of toFixed() that treats floats more like decimals                                   // 210\n\t *                                                                                                     // 211\n\t * Fixes binary rounding issues (eg. (0.615).toFixed(2) === \"0.61\") that present                       // 212\n\t * problems for accounting- and finance-related software.                                              // 213\n\t */                                                                                                    // 214\n\tvar toFixed = lib.toFixed = function(value, precision) {                                               // 215\n\t\tprecision = checkPrecision(precision, lib.settings.number.precision);                                 // 216\n\t\tvar power = Math.pow(10, precision);                                                                  // 217\n                                                                                                        // 218\n\t\t// Multiply up by precision, round accurately, then divide and use native toFixed():                  // 219\n\t\treturn (Math.round(lib.unformat(value) * power) / power).toFixed(precision);                          // 220\n\t};                                                                                                     // 221\n                                                                                                        // 222\n                                                                                                        // 223\n\t/**                                                                                                    // 224\n\t * Format a number, with comma-separated thousands and custom precision/decimal places                 // 225\n\t *                                                                                                     // 226\n\t * Localise by overriding the precision and thousand / decimal separators                              // 227\n\t * 2nd parameter `precision` can be an object matching `settings.number`                               // 228\n\t */                                                                                                    // 229\n\tvar formatNumber = lib.formatNumber = function(number, precision, thousand, decimal) {                 // 230\n\t\t// Resursively format arrays:                                                                         // 231\n\t\tif (isArray(number)) {                                                                                // 232\n\t\t\treturn map(number, function(val) {                                                                   // 233\n\t\t\t\treturn formatNumber(val, precision, thousand, decimal);                                             // 234\n\t\t\t});                                                                                                  // 235\n\t\t}                                                                                                     // 236\n                                                                                                        // 237\n\t\t// Clean up number:                                                                                   // 238\n\t\tnumber = unformat(number);                                                                            // 239\n                                                                                                        // 240\n\t\t// Build options object from second param (if object) or all params, extending defaults:              // 241\n\t\tvar opts = defaults(                                                                                  // 242\n\t\t\t\t(isObject(precision) ? precision : {                                                                // 243\n\t\t\t\t\tprecision : precision,                                                                             // 244\n\t\t\t\t\tthousand : thousand,                                                                               // 245\n\t\t\t\t\tdecimal : decimal                                                                                  // 246\n\t\t\t\t}),                                                                                                 // 247\n\t\t\t\tlib.settings.number                                                                                 // 248\n\t\t\t),                                                                                                   // 249\n                                                                                                        // 250\n\t\t\t// Clean up precision                                                                                // 251\n\t\t\tusePrecision = checkPrecision(opts.precision),                                                       // 252\n                                                                                                        // 253\n\t\t\t// Do some calc:                                                                                     // 254\n\t\t\tnegative = number < 0 ? \"-\" : \"\",                                                                    // 255\n\t\t\tbase = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + \"\",                              // 256\n\t\t\tmod = base.length > 3 ? base.length % 3 : 0;                                                         // 257\n                                                                                                        // 258\n\t\t// Format the number:                                                                                 // 259\n\t\treturn negative + (mod ? base.substr(0, mod) + opts.thousand : \"\") + base.substr(mod).replace(/(\\d{3})(?=\\d)/g, \"$1\" + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1] : \"\");\n\t};                                                                                                     // 261\n                                                                                                        // 262\n                                                                                                        // 263\n\t/**                                                                                                    // 264\n\t * Format a number into currency                                                                       // 265\n\t *                                                                                                     // 266\n\t * Usage: accounting.formatMoney(number, symbol, precision, thousandsSep, decimalSep, format)          // 267\n\t * defaults: (0, \"$\", 2, \",\", \".\", \"%s%v\")                                                             // 268\n\t *                                                                                                     // 269\n\t * Localise by overriding the symbol, precision, thousand / decimal separators and format              // 270\n\t * Second param can be an object matching `settings.currency` which is the easiest way.                // 271\n\t *                                                                                                     // 272\n\t * To do: tidy up the parameters                                                                       // 273\n\t */                                                                                                    // 274\n\tvar formatMoney = lib.formatMoney = function(number, symbol, precision, thousand, decimal, format) {   // 275\n\t\t// Resursively format arrays:                                                                         // 276\n\t\tif (isArray(number)) {                                                                                // 277\n\t\t\treturn map(number, function(val){                                                                    // 278\n\t\t\t\treturn formatMoney(val, symbol, precision, thousand, decimal, format);                              // 279\n\t\t\t});                                                                                                  // 280\n\t\t}                                                                                                     // 281\n                                                                                                        // 282\n\t\t// Clean up number:                                                                                   // 283\n\t\tnumber = unformat(number);                                                                            // 284\n                                                                                                        // 285\n\t\t// Build options object from second param (if object) or all params, extending defaults:              // 286\n\t\tvar opts = defaults(                                                                                  // 287\n\t\t\t\t(isObject(symbol) ? symbol : {                                                                      // 288\n\t\t\t\t\tsymbol : symbol,                                                                                   // 289\n\t\t\t\t\tprecision : precision,                                                                             // 290\n\t\t\t\t\tthousand : thousand,                                                                               // 291\n\t\t\t\t\tdecimal : decimal,                                                                                 // 292\n\t\t\t\t\tformat : format                                                                                    // 293\n\t\t\t\t}),                                                                                                 // 294\n\t\t\t\tlib.settings.currency                                                                               // 295\n\t\t\t),                                                                                                   // 296\n                                                                                                        // 297\n\t\t\t// Check format (returns object with pos, neg and zero):                                             // 298\n\t\t\tformats = checkCurrencyFormat(opts.format),                                                          // 299\n                                                                                                        // 300\n\t\t\t// Choose which format to use for this value:                                                        // 301\n\t\t\tuseFormat = number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero;                      // 302\n                                                                                                        // 303\n\t\t// Return with currency symbol added:                                                                 // 304\n\t\treturn useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(number), checkPrecision(opts.precision), opts.thousand, opts.decimal));\n\t};                                                                                                     // 306\n                                                                                                        // 307\n                                                                                                        // 308\n\t/**                                                                                                    // 309\n\t * Format a list of numbers into an accounting column, padding with whitespace                         // 310\n\t * to line up currency symbols, thousand separators and decimals places                                // 311\n\t *                                                                                                     // 312\n\t * List should be an array of numbers                                                                  // 313\n\t * Second parameter can be an object containing keys that match the params                             // 314\n\t *                                                                                                     // 315\n\t * Returns array of accouting-formatted number strings of same length                                  // 316\n\t *                                                                                                     // 317\n\t * NB: `white-space:pre` CSS rule is required on the list container to prevent                         // 318\n\t * browsers from collapsing the whitespace in the output strings.                                      // 319\n\t */                                                                                                    // 320\n\tlib.formatColumn = function(list, symbol, precision, thousand, decimal, format) {                      // 321\n\t\tif (!list) return [];                                                                                 // 322\n                                                                                                        // 323\n\t\t// Build options object from second param (if object) or all params, extending defaults:              // 324\n\t\tvar opts = defaults(                                                                                  // 325\n\t\t\t\t(isObject(symbol) ? symbol : {                                                                      // 326\n\t\t\t\t\tsymbol : symbol,                                                                                   // 327\n\t\t\t\t\tprecision : precision,                                                                             // 328\n\t\t\t\t\tthousand : thousand,                                                                               // 329\n\t\t\t\t\tdecimal : decimal,                                                                                 // 330\n\t\t\t\t\tformat : format                                                                                    // 331\n\t\t\t\t}),                                                                                                 // 332\n\t\t\t\tlib.settings.currency                                                                               // 333\n\t\t\t),                                                                                                   // 334\n                                                                                                        // 335\n\t\t\t// Check format (returns object with pos, neg and zero), only need pos for now:                      // 336\n\t\t\tformats = checkCurrencyFormat(opts.format),                                                          // 337\n                                                                                                        // 338\n\t\t\t// Whether to pad at start of string or after currency symbol:                                       // 339\n\t\t\tpadAfterSymbol = formats.pos.indexOf(\"%s\") < formats.pos.indexOf(\"%v\") ? true : false,               // 340\n                                                                                                        // 341\n\t\t\t// Store value for the length of the longest string in the column:                                   // 342\n\t\t\tmaxLength = 0,                                                                                       // 343\n                                                                                                        // 344\n\t\t\t// Format the list according to options, store the length of the longest string:                     // 345\n\t\t\tformatted = map(list, function(val, i) {                                                             // 346\n\t\t\t\tif (isArray(val)) {                                                                                 // 347\n\t\t\t\t\t// Recursively format columns if list is a multi-dimensional array:                                // 348\n\t\t\t\t\treturn lib.formatColumn(val, opts);                                                                // 349\n\t\t\t\t} else {                                                                                            // 350\n\t\t\t\t\t// Clean up the value                                                                              // 351\n\t\t\t\t\tval = unformat(val);                                                                               // 352\n                                                                                                        // 353\n\t\t\t\t\t// Choose which format to use for this value (pos, neg or zero):                                   // 354\n\t\t\t\t\tvar useFormat = val > 0 ? formats.pos : val < 0 ? formats.neg : formats.zero,                      // 355\n                                                                                                        // 356\n\t\t\t\t\t\t// Format this value, push into formatted list and save the length:                               // 357\n\t\t\t\t\t\tfVal = useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(val), checkPrecision(opts.precision), opts.thousand, opts.decimal));\n                                                                                                        // 359\n\t\t\t\t\tif (fVal.length > maxLength) maxLength = fVal.length;                                              // 360\n\t\t\t\t\treturn fVal;                                                                                       // 361\n\t\t\t\t}                                                                                                   // 362\n\t\t\t});                                                                                                  // 363\n                                                                                                        // 364\n\t\t// Pad each number in the list and send back the column of numbers:                                   // 365\n\t\treturn map(formatted, function(val, i) {                                                              // 366\n\t\t\t// Only if this is a string (not a nested array, which would have already been padded):              // 367\n\t\t\tif (isString(val) && val.length < maxLength) {                                                       // 368\n\t\t\t\t// Depending on symbol position, pad after symbol or at index 0:                                    // 369\n\t\t\t\treturn padAfterSymbol ? val.replace(opts.symbol, opts.symbol+(new Array(maxLength - val.length + 1).join(\" \"))) : (new Array(maxLength - val.length + 1).join(\" \")) + val;\n\t\t\t}                                                                                                    // 371\n\t\t\treturn val;                                                                                          // 372\n\t\t});                                                                                                   // 373\n\t};                                                                                                     // 374\n                                                                                                        // 375\n                                                                                                        // 376\n\t/* --- Module Definition --- */                                                                        // 377\n                                                                                                        // 378\n\t// Export accounting for CommonJS. If being loaded as an AMD module, define it as such.                // 379\n\t// Otherwise, just add `accounting` to the global object                                               // 380\n\tif (typeof exports !== 'undefined') {                                                                  // 381\n\t\tif (typeof module !== 'undefined' && module.exports) {                                                // 382\n\t\t\texports = module.exports = lib;                                                                      // 383\n\t\t}                                                                                                     // 384\n\t\texports.accounting = lib;                                                                             // 385\n\t} else if (typeof define === 'function' && define.amd) {                                               // 386\n\t\t// Return the library as an AMD module:                                                               // 387\n\t\tdefine([], function() {                                                                               // 388\n\t\t\treturn lib;                                                                                          // 389\n\t\t});                                                                                                   // 390\n\t} else {                                                                                               // 391\n\t\t// Use accounting.noConflict to restore `accounting` back to its original value.                      // 392\n\t\t// Returns a reference to the library's `accounting` object;                                          // 393\n\t\t// e.g. `var numbers = accounting.noConflict();`                                                      // 394\n\t\tlib.noConflict = (function(oldAccounting) {                                                           // 395\n\t\t\treturn function() {                                                                                  // 396\n\t\t\t\t// Reset the value of the root's `accounting` variable:                                             // 397\n\t\t\t\troot.accounting = oldAccounting;                                                                    // 398\n\t\t\t\t// Delete the noConflict method:                                                                    // 399\n\t\t\t\tlib.noConflict = undefined;                                                                         // 400\n\t\t\t\t// Return reference to the library to re-assign it:                                                 // 401\n\t\t\t\treturn lib;                                                                                         // 402\n\t\t\t};                                                                                                   // 403\n\t\t})(root.accounting);                                                                                  // 404\n                                                                                                        // 405\n\t\t// Declare `fx` on the root (global/window) object:                                                   // 406\n\t\troot['accounting'] = lib;                                                                             // 407\n\t}                                                                                                      // 408\n                                                                                                        // 409\n\t// Root will be `window` in browser or `global` on the server:                                         // 410\n}(this));                                                                                               // 411\n                                                                                                        // 412\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}
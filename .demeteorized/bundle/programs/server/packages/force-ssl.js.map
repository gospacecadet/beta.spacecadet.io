{"version":3,"sources":["meteor://ðŸ’»app/packages/force-ssl/force_ssl_common.js","meteor://ðŸ’»app/packages/force-ssl/force_ssl_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AACA,4G;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6G","file":"/packages/force-ssl.js","sourcesContent":["_.extend(Meteor.absoluteUrl.defaultOptions, {secure: true});\n","var url = Npm.require(\"url\");\n\n// Unfortunately we can't use a connect middleware here since\n// sockjs installs itself prior to all existing listeners\n// (meaning prior to any connect middlewares) so we need to take\n// an approach similar to overshadowListeners in\n// https://github.com/sockjs/sockjs-node/blob/cf820c55af6a9953e16558555a31decea554f70e/src/utils.coffee\n\nvar httpServer = WebApp.httpServer;\nvar oldHttpServerListeners = httpServer.listeners('request').slice(0);\nhttpServer.removeAllListeners('request');\nhttpServer.addListener('request', function (req, res) {\n\n  // allow connections if they have been handled w/ ssl already\n  // (either by us or by a proxy) OR the connection is entirely over\n  // localhost (development mode).\n  //\n  // Note: someone could trick us into serving over non-ssl by setting\n  // x-forwarded-for or x-forwarded-proto. Not much we can do there if\n  // we still want to operate behind proxies.\n\n  var remoteAddress =\n        req.connection.remoteAddress || req.socket.remoteAddress;\n  // Determine if the connection is only over localhost. Both we\n  // received it on localhost, and all proxies involved received on\n  // localhost.\n  var localhostRegexp = /^\\s*(127\\.0\\.0\\.1|::1)\\s*$/;\n  var isLocal = (\n    localhostRegexp.test(remoteAddress) &&\n      (!req.headers['x-forwarded-for'] ||\n       _.all(req.headers['x-forwarded-for'].split(','), function (x) {\n         return localhostRegexp.test(x);\n       })));\n\n  // Determine if the connection was over SSL at any point. Either we\n  // received it as SSL, or a proxy did and translated it for us.\n  var isSsl = req.connection.pair ||\n      (req.headers['x-forwarded-proto'] &&\n       req.headers['x-forwarded-proto'].indexOf('https') !== -1);\n\n  if (!isLocal && !isSsl) {\n    // connection is not cool. send a 302 redirect!\n\n    var host = url.parse(Meteor.absoluteUrl()).hostname;\n\n    // strip off the port number. If we went to a URL with a custom\n    // port, we don't know what the custom SSL port is anyway.\n    host = host.replace(/:\\d+$/, '');\n\n    res.writeHead(302, {\n      'Location': 'https://' + host + req.url\n    });\n    res.end();\n    return;\n  }\n\n  // connection is OK. Proceed normally.\n  var args = arguments;\n  _.each(oldHttpServerListeners, function(oldListener) {\n    oldListener.apply(httpServer, args);\n  });\n});\n\n\n// NOTE: this doesn't handle websockets!\n//\n// Websockets come in via the 'upgrade' request. We can override this,\n// however the problem is we're not sure if the websocket is actually\n// encrypted. We don't get x-forwarded-for or x-forwarded-proto on\n// websockets. It's possible the 'sec-websocket-origin' header does\n// what we want, but that's not clear.\n//\n// For now, this package allows raw unencrypted DDP connections over\n// websockets.\n"]}
{"version":3,"sources":["meteor://ðŸ’»app/packages/ongoworks_security/lib/server/security-util.js","meteor://ðŸ’»app/packages/ongoworks_security/lib/server/security-deny.js","meteor://ðŸ’»app/packages/ongoworks_security/lib/server/security-api.js","meteor://ðŸ’»app/packages/ongoworks_security/lib/security-rules.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH;;;;;;;;;;;;;;;;;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gH;;;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH;;;;;;;;;;;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH","file":"/packages/ongoworks_security.js","sourcesContent":["/* global _, rulesByCollection:true, addFuncForAll:true, ensureCreated:true, ensureDefaultAllow:true */\n\nrulesByCollection = {};\n\nvar created = {\n  allow: {\n    insert: {},\n    update: {},\n    remove: {},\n    download: {} // for use with CollectionFS packages\n  },\n  deny: {\n    insert: {},\n    update: {},\n    remove: {},\n    download: {} // for use with CollectionFS packages\n  }\n};\n\n/**\n * Adds the given function as an allow or deny function for all specified collections and types.\n * @param {Array(Mongo.Collection)} collections Array of Mongo.Collection instances\n * @param {String}                  allowOrDeny \"allow\" or \"deny\"\n * @param {Array(String)}           types       Array of types (\"insert\", \"update\", \"remove\")\n * @param {Array(String)|null}      fetch       `fetch` property to use\n * @param {Function}                func        The function\n */\naddFuncForAll = function addFuncForAll(collections, allowOrDeny, types, fetch, func) {\n  // We always disable transformation, but we transform for specific\n  // rules upon running our deny function if requested.\n  var rules = {transform: null};\n  if (_.isArray(fetch)) {\n    rules.fetch = fetch;\n  }\n  _.each(types, function (t) {\n    rules[t] = func;\n  });\n  _.each(collections, function (c) {\n    c[allowOrDeny](rules);\n  });\n};\n\n/**\n * Creates the allow or deny function for the given collections if not already created. This ensures that this package only ever creates up to one allow and one deny per collection.\n * @param   {String}                  allowOrDeny \"allow\" or \"deny\"\n * @param   {Array(Mongo.Collection)} collections An array of collections\n * @param   {Array(String)}           types       An array of types (\"insert\", \"update\", \"remove\")\n * @param   {Array(String)|null}      fetch       `fetch` property to use\n * @param   {Function}                func        The function\n */\nensureCreated = function ensureCreated(allowOrDeny, collections, types, fetch, func) {\n  _.each(types, function (t) {\n    collections = _.reject(collections, function (c) {\n      return _.has(created[allowOrDeny][t], getCollectionName(c));\n    });\n    addFuncForAll(collections, allowOrDeny, [t], null, func);\n    // mark that we've defined function for collection-type combo\n    _.each(collections, function (c) {\n      created[allowOrDeny][t][getCollectionName(c)] = true;\n    });\n  });\n};\n\n/**\n * Sets up default allow functions for the collections and types.\n * @param   {Array(Mongo.Collection)} collections Array of Mongo.Collection instances\n * @param   {Array(String)}           types       Array of types (\"insert\", \"update\", \"remove\")\n */\nensureDefaultAllow = function ensureDefaultAllow(collections, types) {\n  ensureCreated(\"allow\", collections, types, [], function () {\n    return true;\n  });\n};\n\n/**\n * Return only those rules that apply to the given collection and operation type\n */\ngetRulesForCollectionAndType = function getRulesForCollectionAndType(collectionName, type) {\n  var rules = rulesByCollection[collectionName] || [];\n  return _.select(rules, function (rule) {\n    return _.contains(rule._types, type);\n  });\n};\n\ncomputeChangedFieldsFromModifier = function computeChangedFieldsFromModifier(modifier) {\n  var fields = [];\n  // This is the same logic Meteor's mongo package uses in\n  // https://github.com/meteor/meteor/blob/devel/packages/mongo/collection.js\n  _.each(modifier, function (params) {\n    _.each(_.keys(params), function (field) {\n      // treat dotted fields as if they are replacing their\n      // top-level part\n      if (field.indexOf('.') !== -1)\n        field = field.substring(0, field.indexOf('.'));\n\n      // record the field we are trying to change\n      if (!_.contains(fields, field))\n        fields.push(field);\n    });\n  });\n  return fields;\n};\n\ngetCollectionName = function getCollectionName(collection) {\n  // CollectionFS has underlying collection on `files` property\n  return collection._name || (collection.files && collection.files._name);\n};\n","/*\n * A single deny function runs all the deny functions registered by this package, allowing us to have\n * an OR relationship among multiple security rule chains.\n */\n\nallRulesPass = function allRulesPass(collection, type, args) {\n  // select only those rules that apply to this operation type\n  var rules = getRulesForCollectionAndType(getCollectionName(collection), type);\n\n  // Loop through all defined rules for this collection. There is an OR relationship among\n  // all rules for the collection, so if any do NOT return true, we allow.\n  return !_.every(rules, function (rule) {\n    return rule.deny(type, collection, args);\n  });\n};\n\nensureSecureDeny = function ensureSecureDeny(collections, types) {\n  _.each(types, function (t) {\n    _.each(collections, function (collection) {\n      ensureCreated(\"deny\", [collection], [t], null, function () {\n        return !allRulesPass(collection, t, _.toArray(arguments));\n      });\n    });\n  });\n};\n","// The `Security` object is exported and provides the package API\nSecurity = {\n  // Putting these on the exported object allows package users to override if necessary\n  errorMessages: {\n    multipleCan: 'You may not combine more than one insert, update, or remove on a Security.can chain',\n    notAllowed: 'Action not allowed',\n    requiresDeny: 'Security.defineMethod requires a \"deny\" function',\n    collectionsArg: 'The collections argument must be a Mongo.Collection instance or an array of them',\n    noCollectionOrType: 'At a minimum, you must call permit and collections methods for a security rule.',\n    updateArgs: 'The update method for Security.can requires two arguments, id and modifier'\n  },\n  Rule: function SecurityRuleConstructor(types) {\n    var self = this;\n\n    if (!_.isArray(types)) {\n      types = [types];\n    }\n    self._types = types;\n    self._restrictions = [];\n  },\n  // the starting point of the chain\n  permit: function permit(types) {\n    return new Security.Rule(types);\n  },\n  Check: function SecurityCheckConstructor(userId) {\n    this.userId = userId || null;\n  },\n  can: function can(userId) {\n    return new Security.Check(userId);\n  },\n  defineMethod: function securityDefineMethod(name, definition) {\n    // Check whether a rule with the given name already exists; can't overwrite\n    if (Security.Rule.prototype[name]) {\n      throw new Error('A security method with the name \"' + name + '\" has already been defined');\n    }\n    // Make sure the definition argument is an object that has a `deny` property\n    if (!definition || !definition.deny) {\n      throw new Error(Security.errorMessages.requiresDeny);\n    }\n    // Wrap transform, if provided\n    if (definition.transform) {\n      definition.transform = LocalCollection.wrapTransform(definition.transform);\n    }\n    Security.Rule.prototype[name] = function (arg) {\n      var self = this;\n      self._restrictions.push({\n        definition: definition,\n        arg: arg\n      });\n      return self;\n    };\n  }\n};\n\n// Security.Rule prototypes\nSecurity.Rule.prototype.collections = function (collections) {\n  var self = this;\n  // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n  // an array of them. If it's a single collection, convert it to a one-item array.\n  if (!_.isArray(collections)) collections = [collections];\n\n  // Keep list keyed by collection name\n  _.each(collections, function (collection) {\n    if (!(collection instanceof Mongo.Collection) &&\n        // CollectionFS has underlying collection on `files` property\n       !(collection.files instanceof Mongo.Collection)) {\n      throw new Error(Security.errorMessages.collectionsArg);\n    }\n    // CollectionFS has underlying collection on `files` property\n    var n = getCollectionName(collection);\n    rulesByCollection[n] = rulesByCollection[n] || [];\n    rulesByCollection[n].push(self);\n  });\n\n  self._collections = collections;\n\n  return self;\n};\n\nSecurity.Rule.prototype.apply = function () {\n  var self = this;\n\n  if (!self._collections || !self._types) {\n    throw new Error(Security.errorMessages.noCollectionOrType);\n  }\n\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(self._collections, self._types);\n\n  // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n  // or a function that takes the argument passed to the restriction method and returns an array.\n  // TODO for now we can't set fetch accurately; maybe need to adjust API so that we \"apply\" only\n  // after we've defined all rules\n  //var fetch = [];\n  //_.each(self._restrictions, function (restriction) {\n  //  if (_.isArray(restriction.definition.fetch)) {\n  //    fetch = fetch.concat(restriction.definition.fetch);\n  //  } else if (typeof restriction.definition.fetch === \"function\") {\n  //    fetch = fetch.concat(restriction.definition.fetch(restriction.arg));\n  //  }\n  //});\n\n  ensureSecureDeny(self._collections, self._types);\n\n};\n\nSecurity.Rule.prototype.deny = function (type, collection, args) {\n  var self = this;\n  // Loop through all defined restrictions. Restrictions are additive for this chained\n  // rule, so if any deny function returns true, this function should return true.\n  return _.any(self._restrictions, function (restriction) {\n    var doc, transform = restriction.definition.transform;\n\n    // If transform is a function, apply that\n    if (typeof transform === 'function') {\n      if (type === 'insert') {\n        doc = EJSON.clone(args[1]);\n        // The wrapped transform requires an _id, but we\n        // don't have access to the generatedId from Meteor API,\n        // so we'll fudge one and then remove it.\n        doc._id = Random.id();\n      } else {\n        doc = args[1];\n      }\n      args[1] = transform(doc);\n      if (type === 'insert') {\n        delete args[1]._id;\n      }\n    }\n\n    // If not transform: null, apply the collection transform\n    else if (transform !== null && typeof collection._transform === 'function') {\n      if (type === 'insert') {\n        doc = EJSON.clone(args[1]);\n        // The wrapped transform requires an _id, but we\n        // don't have access to the generatedId from Meteor API,\n        // so we'll fudge one and then remove it.\n        doc._id = Random.id();\n      } else {\n        doc = args[1];\n      }\n      args[1] = collection._transform(doc);\n      if (type === 'insert') {\n        delete args[1]._id;\n      }\n    }\n\n    return restriction.definition.deny.apply(this, [type, restriction.arg].concat(args));\n  });\n};\n\nMongo.Collection.prototype.permit = function (types) {\n  return Security.permit(types).collections(this);\n};\n\n// Security.Check prototypes\nSecurity.Check.prototype.for = function (collection) {\n  var self = this;\n  self.collection = collection;\n  return self;\n};\n\n['insert', 'update', 'remove'].forEach(function (type) {\n  Security.Check.prototype[type] = function () {\n    var self = this;\n    if (self.type) throw new Error(Security.errorMessages.multipleCan);\n    self.type = type;\n    self.args = _.toArray(arguments);\n    // Compute and add fields argument for update type\n    if (type === 'update') {\n      if (self.args.length !== 2) throw new Error(Security.errorMessages.updateArgs);\n      self.args = [\n        self.args[0],\n        computeChangedFieldsFromModifier(self.args[1]),\n        self.args[1]\n      ];\n    }\n    return self;\n  };\n});\n\n// Security.can(userId).insert(doc).for(MyCollection).check()\n// Security.can(userId).update(id, modifier).for(MyCollection).check()\n// Security.can(userId).remove(id).for(MyCollection).check()\nSecurity.Check.prototype.check = function () {\n  var self = this;\n  return allRulesPass(self.collection, self.type, [self.userId].concat(self.args));\n};\n\n// Security.can(userId).insert(doc).for(MyCollection).throw()\n// Security.can(userId).update(id, modifier).for(MyCollection).throw()\n// Security.can(userId).remove(id).for(MyCollection).throw()\nSecurity.Check.prototype.throw = function () {\n  if (!this.check()) throw new Meteor.Error('access-denied', Security.errorMessages.notAllowed);\n};\n","/*\n * This file defines built-in restriction methods\n */\n\n/*\n * No one\n */\n\nSecurity.defineMethod(\"never\", {\n  fetch: [],\n  transform: null,\n  deny: function () {\n    return true;\n  }\n});\n\n/*\n * Logged In\n */\n\nSecurity.defineMethod(\"ifLoggedIn\", {\n  fetch: [],\n  transform: null,\n  deny: function (type, arg, userId) {\n    return !userId;\n  }\n});\n\n/*\n * Specific User ID\n */\n\nSecurity.defineMethod(\"ifHasUserId\", {\n  fetch: [],\n  transform: null,\n  deny: function (type, arg, userId) {\n    return userId !== arg;\n  }\n});\n\n/*\n * Specific Roles\n */\n\n/*\n * alanning:roles support\n */\nif (Package && Package[\"alanning:roles\"]) {\n\n  var Roles = Package[\"alanning:roles\"].Roles;\n\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    transform: null,\n    deny: function (type, arg, userId) {\n      if (!arg) {\n        throw new Error('ifHasRole security rule method requires an argument');\n      }\n      if (arg.role) {\n        return !Roles.userIsInRole(userId, arg.role, arg.group);\n      } else {\n        return !Roles.userIsInRole(userId, arg);\n      }\n    }\n  });\n\n}\n\n/*\n * nicolaslopezj:roles support\n * Note: doesn't support groups\n */\nif (Package && Package[\"nicolaslopezj:roles\"]) {\n\n  var Roles = Package[\"nicolaslopezj:roles\"].Roles;\n\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    transform: null,\n    deny: function (type, arg, userId) {\n      if (!arg) {\n        throw new Error('ifHasRole security rule method requires an argument');\n      }\n      return !Roles.userHasRole(userId, arg);\n    }\n  });\n\n}\n\n/*\n * Specific Properties\n */\n\nSecurity.defineMethod(\"onlyProps\", {\n  fetch: [],\n  transform: null,\n  deny: function (type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) {\n      arg = [arg];\n    }\n\n    fieldNames = fieldNames || _.keys(doc);\n\n    return !_.every(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  }\n});\n\nSecurity.defineMethod(\"exceptProps\", {\n  fetch: [],\n  transform: null,\n  deny: function (type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) {\n      arg = [arg];\n    }\n\n    fieldNames = fieldNames || _.keys(doc);\n\n    return _.any(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  }\n});\n"]}